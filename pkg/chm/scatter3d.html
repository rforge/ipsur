<html><head><title>Three-Dimensional Scatterplots and Point Identification</title>
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>scatter3d(Rcmdr)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   scatter3d">
<param name="keyword" value="R:   identify3d">
<param name="keyword" value=" Three-Dimensional Scatterplots and Point Identification">
</object>


<h2>Three-Dimensional Scatterplots and Point Identification</h2>


<h3>Description</h3>

<p>
The <code>scatter3d</code> function uses the <code>rgl</code> package to draw 3D scatterplots
with various regression surfaces. The function <code>identify3d</code> 
allows you to label points interactively with the mouse:
Press the right mouse button (on a two-button mouse) or the centre button (on a
three-button mouse), drag a 
rectangle around the points to be identified, and release the button. 
Repeat this procedure for each point or
set of ``nearby'' points to be identified. To exit from point-identification mode,
click the right (or centre) button an empty region of the plot.
</p>


<h3>Usage</h3>

<pre>
scatter3d(x, y, z, 
        xlab=deparse(substitute(x)), ylab=deparse(substitute(y)),
        axis.scales=TRUE,                          
        zlab=deparse(substitute(z)), revolutions=0, bg.col=c("white", "black"), 
        axis.col=if (bg.col == "white") c("darkmagenta", "black", "darkcyan") 
            else c("darkmagenta", "white", "darkcyan"),
        surface.col=c("blue", "green", "orange", "magenta", "cyan", "red", "yellow", "gray"),
        neg.res.col="red", pos.res.col="green", 
        square.col=if (bg.col == "white") "black" else "gray", point.col="yellow",
        text.col=axis.col, grid.col=if (bg.col == "white") "black" else "gray",
        fogtype=c("exp2", "linear", "exp", "none"),
        residuals=(length(fit) == 1), surface=TRUE, fill=TRUE, grid=TRUE, grid.lines=26,
        df.smooth=NULL, df.additive=NULL,
        sphere.size=1, threshold=0.01, speed=1, fov=60,
        fit="linear", groups=NULL, parallel=TRUE, ellipsoid=FALSE, level=0.5,
        model.summary=FALSE)
    
identify3d(x, y, z, axis.scales=TRUE, groups=NULL, labels=1:length(x), 
    col=c("blue", "green", "orange", "magenta", "cyan", "red", "yellow", "gray"),
    offset = ((100/length(x))^(1/3)) * 0.02)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
variable for horizontal axis.</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
variable for vertical axis (response).</td></tr>
<tr valign="top"><td><code>z</code></td>
<td>
variable for out-of-screen axis.</td></tr>
<tr valign="top"><td><code>xlab, ylab, zlab</code></td>
<td>
axis labels.</td></tr>
<tr valign="top"><td><code>axis.scales</code></td>
<td>
if <code>TRUE</code>, label the values of the ends of the axes.
<EM>Note:</EM> For <code>identify3d</code> to work properly, the value of this argument must
be the same as in <code>scatter3d</code>.</td></tr>
<tr valign="top"><td><code>revolutions</code></td>
<td>
number of full revolutions of the display.</td></tr>
<tr valign="top"><td><code>bg.col</code></td>
<td>
background colour; one of <code>"white"</code>, <code>"black"</code>.</td></tr>
<tr valign="top"><td><code>axis.col</code></td>
<td>
colours for axes; if <code>axis.scales</code> is <code>FALSE</code>, then
the second colour is used for all three axes.</td></tr>
<tr valign="top"><td><code>surface.col</code></td>
<td>
vector of colours for regression planes, 
used in the order specified by <code>fit</code>.</td></tr>
<tr valign="top"><td><code>neg.res.col, pos.res.col</code></td>
<td>
colours for lines representing negative 
and positive residuals.</td></tr>
<tr valign="top"><td><code>square.col</code></td>
<td>
colour to use to plot squared residuals.</td></tr>
<tr valign="top"><td><code>point.col</code></td>
<td>
colour of points.</td></tr>
<tr valign="top"><td><code>text.col</code></td>
<td>
colour of axis labels.</td></tr>
<tr valign="top"><td><code>grid.col</code></td>
<td>
colour of grid lines on the regression surface(s).</td></tr>
<tr valign="top"><td><code>fogtype</code></td>
<td>
type of fog effect; one of <code>"exp2"</code>, <code>"linear"</code>, 
<code>"exp"</code>, <code>"none".</code></td></tr>
<tr valign="top"><td><code>residuals</code></td>
<td>
plot residuals if <code>TRUE</code>; if  <code>residuals="squares"</code>,
then the squared residuals are shown as squares (using code adapted from Richard
Heiberger). Residuals are available only when there is one surface plotted.</td></tr>
<tr valign="top"><td><code>surface</code></td>
<td>
plot surface(s) (<code>TRUE</code> or <code>FALSE</code>).</td></tr>
<tr valign="top"><td><code>fill</code></td>
<td>
fill the plotted surface(s) with colour (<code>TRUE</code> or <code>FALSE</code>).</td></tr>
<tr valign="top"><td><code>grid</code></td>
<td>
plot grid lines on the regression surface(s) (<code>TRUE</code> or <code>FALSE</code>).</td></tr>
<tr valign="top"><td><code>grid.lines</code></td>
<td>
number of lines (default, 26) forming the grid, in each of the x and y directions.</td></tr>
<tr valign="top"><td><code>df.smooth</code></td>
<td>
degrees of freedom for the two-dimensional smooth regression surface;
if <code>NULL</code> (the default), the <code><a onclick="findlink('mgcv', 'gam.html')" style="text-decoration: underline; color: blue; cursor: hand">gam</a></code> function will select the degrees of freedom
for a smoothing spline by generalized cross-validation; if a positive number, a fixed
regression spline will be fit with the specified degrees of freedom.</td></tr>
<tr valign="top"><td><code>df.additive</code></td>
<td>
degrees of freedom for each explanatory variable in an additive regression;
if <code>NULL</code> (the default), the <code>gam</code> function will select degrees of freedom 
for the smoothing splines by generalized cross-validation; if a positive number
or a vector of two positive numbers, fixed
regression splines will be fit with the specified degrees of freedom for each term.</td></tr>
<tr valign="top"><td><code>sphere.size</code></td>
<td>
relative sizes of spheres representing points; 
the actual size is dependent on the number of observations.</td></tr>
<tr valign="top"><td><code>threshold</code></td>
<td>
if the actual size of the spheres is less than the threshold, 
points are plotted instead.</td></tr>
<tr valign="top"><td><code>speed</code></td>
<td>
relative speed of revolution of the plot.</td></tr>
<tr valign="top"><td><code>fov</code></td>
<td>
field of view (in degrees); controls degree of perspective.</td></tr>
<tr valign="top"><td><code>fit</code></td>
<td>
one or more of <code>"linear"</code>, <code>"quadratic"</code>, <code>"smooth"</code>, 
<code>"additive"</code>; to display fitted surface(s); partial matching is supported &ndash; 
e.g., <code>c("lin", "quad")</code>.</td></tr>
<tr valign="top"><td><code>groups</code></td>
<td>
if <code>NULL</code> (the default), no groups are defined; if a factor, a different surface
or set of surfaces is plotted for each level of the factor; in this event, the colours in 
<code>plane.col</code> are used successively for the points, surfaces, and residuals corresponding to
each level of the factor.</td></tr>
<tr valign="top"><td><code>parallel</code></td>
<td>
when plotting surfaces by <code>groups</code>, should the surfaces be constrained to be
parallel? A logical value, with default <code>TRUE</code>.</td></tr>
<tr valign="top"><td><code>ellipsoid</code></td>
<td>
plot concentration ellipsoid(s) (<code>TRUE</code> or <code>FALSE</code>).</td></tr>
<tr valign="top"><td><code>level</code></td>
<td>
expected proportion of bivariate-normal observations included in the
concentration ellipsoid(s); default is 0.5.</td></tr>
<tr valign="top"><td><code>model.summary</code></td>
<td>
print summary or summaries of the model(s) fit 
(<code>TRUE</code> or <code>FALSE</code>). <code>scatter3d</code> rescales the three variables 
internally to fit in the unit cube; this rescaling will affect regression 
coefficients.</td></tr>
<tr valign="top"><td><code>labels</code></td>
<td>
text labels for the points, one for each point; defaults to
the observation indices.</td></tr>
<tr valign="top"><td><code>col</code></td>
<td>
colours for the point labels, given by group. There must be at
least as many colours as groups; if there are no groups, the first colour is used. Normally, the colours
would correspond to the <code>plane.col</code> argument to <code>scatter3d</code>.</td></tr>
<tr valign="top"><td><code>offset</code></td>
<td>
vertical displacement for point labels (to avoid overplotting by points).</td></tr>
</table>

<h3>Value</h3>

<p>
<code>scatter3d</code> not return a useful value; it is used for its side-effect of
creating a 3D scatterplot. <code>indentify3d</code> returns the labels of the
identified points.</p>

<h3>Note</h3>

<p>
You have to install the <code>rgl</code> and <code>mgcv</code> packages to produce 3D plots.
</p>


<h3>Author(s)</h3>

<p>
John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p>
<code><a onclick="findlink('rgl', 'rgl.open.html')" style="text-decoration: underline; color: blue; cursor: hand">rgl.open</a></code>, <code><a onclick="findlink('mgcv', 'gam.html')" style="text-decoration: underline; color: blue; cursor: hand">gam</a></code>
</p>


<h3>Examples</h3>

<pre>
    ## Not run: 
State.x77 &lt;- as.data.frame(state.x77)
with(State.x77, scatter3d(Income, Murder, Illiteracy))
with(State.x77, identify3d(Income, Murder, Illiteracy, labels=row.names(State.x77)))
with(State.x77,  scatter3d(Income, Murder, Illiteracy, fit=c("linear", "quadratic")))
    
## End(Not run)
</pre>

<script Language="JScript">
function findlink(pkg, fn) {
var Y, link;
Y = location.href.lastIndexOf("\\") + 1;
link = location.href.substring(0, Y);
link = link + "../../" + pkg + "/chtml/" + pkg + ".chm::/" + fn;
location.href = link;
}
</script>


<hr><div align="center">[Package <em>Rcmdr</em> version 1.2-6 <a href="00Index.html">Index]</a></div>

</body></html>
